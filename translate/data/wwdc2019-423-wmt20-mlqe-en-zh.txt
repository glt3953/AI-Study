大家好 ， 我叫斯宾塞 · 鲁森 ， 我是苹果演出队的工程师。
今天 ， 我很高兴告诉你如何优化应用程序的启动。
我们今天将讨论这四个主题。
首先 ， 发射是什么 ？ 什么是不同类型的发射以及我们如何将它们细分为不同的子阶段 ？ 接下来 ， 我们将讨论如何恰当地测量你的应用程序的发射。
在该领域外 ， iOS 设备可能处于各种不同的状态和条件下 ， 这些状态和条件可能产生不一致的发射结果。
所以 ， 了解这些状态以及在测量时如何减少它们的影响是很重要的。
一旦你做到了这一点 ， 你就可以看看如何使用仪器来描述和理解你的应用程序来寻找改进它的机会。
最后 ， 我们将为您提供一些技巧和技巧 ， 如何监控您的应用程序在一段时间内和实地的推出 ， 以确保您始终如一地向您的所有用户提供愉快的体验。
那么 ， 我所说的那个应用程序发射是什么 ？ 嗯 ， 应用程序发射是用户体验的中断。
我的意思是什么? ， 让我们看看。
好了 ， 准备好了 ， 准备好了。
哇 ， 在 iPhone 6S + 上 ， 发射量接近 2 次。
5 秒钟 ， 这并不像我们的用户所期望的那么令人愉快。
你知道的 ， 很重要的是要让人愉快 ， 因为会发生很多事情。
事实上 ， 在所有 iOS 设备中 ， 每天都会发生数十亿次。
所以 ， 我们做了一些压缩 ， 并且我们知道 ， 只要我们在每次发射中只节省 1 毫秒 ， 我们就可以节省惊人的 162 天的发射时间 ， 是的 ， 换句话说 ， 谢谢你 ， 这就是向火星发射火箭所需要的时间。
但由于其他一些原因 ， 这也很重要。
首先 ， 您的应用程序的启动是您的用户 ， 第一次体验您的应用程序 ， 因此 ， 它应该是令人愉快的。
现在重要的是要记住 ， 作为开发人员 ， 我们倾向于转向更新的设备。
因此 ， 重要的是要确保您所看到的体验与客户、您的用户在不同的 iOS 设备上和不同的条件下所掌握的体验相同。
此外 ， 发射覆盖了你的代码基础的很大一部分 ， 从底漆到初始化 ， 到查看创建等等。
因此 ， 如果你看到你的发布不像你的用户所期望的那么令人愉快 ， 这可能表明你的代码库的其他部分也是令人愉快的。
最后 ， 发射是一个非常紧张的时间的电话。
涉及大量 CPU 工作和大量内存工作.
因此 ， 您应该尝试减少这一点 ， 因为它影响到系统的性能 ， 当然也影响到您的用户的电池寿命。
所以 ， 让我们来看看我以前说过的发射 ， 有一个冷发射 ， 一个温暖发射 ， 有些经常被称为发射 ， 但不是发射 ， 一个简历。
冷发射发生在重新启动后 ， 或当你的应用程序已经很长时间没有发射。
为了启动应用程序 ， 我们需要将其从磁盘中带入内存 ， 启动支持应用程序的系统侧服务 ， 然后生成过程。
正如你预料的那样 ， 这可能需要一点时间 ， 但幸运的是 ， 一旦事情发生了一次 ， 你将体验一次温暖的发射。
在这种情况下 ， 您的应用程序仍然需要生成 ， 但我们已经将您的应用程序带入内存 ， 并启动了一些系统侧服务。
因此 ， 这将会更快一点 ， 也会更一致一点。
最后 ， 那是简历。
当用户从主屏幕或应用程序交换机返回应用程序时 ， 就会发生这种情况。
如你所知 ， 这个应用程序已经在这个时候启动了 ， 所以它将是非常快的。
从这里你需要记住的是 ， 在测量时不要把简历和发射混淆起来。
因此 ， 考虑到这一信息 ， 如果发射速度快、速度快、速度快 ， 我们怎么能做到这一点呢 ？ 那么 ， 我们需要达到在 400 毫秒内完成第一个框架的目标。
这使得我们在启动动画期间向用户显示像素 ， 到启动动画完成时 ， 您的应用程序是交互的和响应的。
做到这一点的第一步是了解发射期间发生的情况。
所以 ， 让我们启动地图。
如你所知 ， 启动一般是在用户在你的主屏上点击你的图标时开始的。
然后在接下来的大约 100 毫秒内 ， iOS 将完成必要的系统侧工作 ， 以便初始化应用程序。
这样 ， 您就可以作为开发人员创建您的视图 ， 加载您的内容 ， 并生成您的第一个帧。
现在 ， 这个框架不一定需要完全完成。
它可以为异步加载数据提供一些占位符 ， 但此时您的应用程序应该是交互的和响应的。
因此 ， 就地图而言 ， 所有瓷砖尚未装货。
您仍然可以启动您的搜索和浏览您的喜好。
然后在接下来的几百毫秒内 ， 您可以显示该异步加载的数据并为您的用户生成您的最后框架。
让我们仔细看看这些阶段。
这六个阶段涵盖从系统初始化到应用程序初始化到查看创建和布局的所有内容 ， 然后取决于您的应用程序 ， 这可能是您的数据的异步加载阶段 ， 即扩展阶段。
系统接口的上半部是染色的.
对于那些不熟悉的人 ， 动态链接器会加载您的共享库和框架。
现在在 2017 年, 我们引入了染料 3, 它为系统增添了激动人心的优化.
我们很高兴宣布 ， 在 iOS 13 中 ， 我们会将这些优化引入到你的应用程序中。
这意味着我们现在正在缓存您的运行时依赖 ， 或温暖的发射 ， 这应该给他们一个显著的速度改进。
谢谢。
现在有了一个新的链接, 提出了一些新的建议.
为了充分利用这些新的改进 ， 我们建议您避免连接未使用的框架 ， 因为这可能有隐藏的成本 ， 我们将在稍后向您展示。
我们还建议您避免动态库加载 ， 如 DLOpen 或 NSbundleLoad ， 因为这将使您失去通过在您的高速缓存中获得的那些胜利。
最后 ， 这意味着您应该很难连接您的所有依赖 ， 因为它现在比以前更快。
系统接口的下半部是 libSystems Init.
这就是我们在应用程序中初始化低级系统组件的时候。
现在这主要是系统方面的工作 ， 有固定的成本。
所以 ， 使用开发人员不需要专注于这一部分。
现在我们有静态运行时初始化。
这是当系统初始化您的目标 C 和快速运行时间。
现在 ， 一般来说 ， 应用程序不应该在这里做任何工作 ， 除非你有静态初始化方法 ， 这些方法可能出现在你的代码中 ， 或者更有可能从链接的框架中得到一个惊喜。
一般而言 ， 我们不推荐静态初始化。
所以 ， 让我们花一点时间讨论如何减少其影响。
如果您拥有一个使用静态初始化的框架 ， 考虑披露 API 来尽早初始化堆栈。
但是 ， 如果您必须使用静态初始化 ， 请考虑将代码从在启动期间每次调用的类负载移到类初始化 ， 而类初始化是在您使用类内部的方法时松散地调用的。
下一步是 UIKit 初始化。
这是当系统实例化您的应用程序和您的应用程序委托时.
这在很大程度上是系统方面的工作 ， 建立了事件处理和与系统的集成。
但是 ， 如果您的 UI 应用程序子类或您在 UI 应用程序委托初始化器中做任何工作 ， 您仍然可以实现此阶段。
现在我们有了应用程序初始化。
这就是好东西的地方。
这就是开发人员可能对应用程序的启动产生最大影响的地方。
对于那些尚未在 API 中采用新的 UIC 或正在瞄准 iOS 12 或更早的用户 ， 应用程序 Init 同样使用这些委托回调方法。
申请 ： 将完成备选方案 ， 申请 ： 已完成备选方案。
当您的应用程序显示给用户时, 其他的方法, 应用程序 DidBecomein: 将被调用.
现在重要的是要知道 ， 如果您没有 UIScenes ， 您应该创建您的视图控制器并完成选项。
这是因为与 UIScene, 应用程序 Init 的工作有点不同.
现在您仍将获得 "完成发射" 和 "完成发射" 选项 ， 但当您的应用程序显示给用户时 ， 您将获得 UIScene委托的生命周期回调。
当然 ， 这些是场景 ： 将与选项连接。
情景喜剧《未来》和风景秀丽的《迪多梅活动》.
您应该创建您的视图控制器 ， 和场景 ： 将连接到分流选项。
重要的是要注意 ， 您应该只创建视图控制器和场景 ： 将连接到选项 ， 这也是 ， 并完成了选项的发射。
这种常见的陷阱 ， 当然会导致性能损失 ， 并且很可能会在代码基础上出现不可预测的错误。
无论你是否采用了新的 UIScene API ， 我们对这一阶段的建议大致是一样的。
您应该推迟任何无关的工作 ， 但没有必要提交您的第一个框架 ， 要么将它推进到背景队列中 ， 要么在稍后完全完成。
如果你确实采用了 UIScenes ， 你可以再做一件事 ， 那就是确保你在你的网站之间分享你的资源。
当然 ， 这是为了减少不必要地多次从事任何工作的间接费用。
要了解更多关于 UIScenes 的信息 ， 请看看本周早些时候的这两次谈话。
下一步是第一个帧渲染阶段。
现在 ， 这相对直截了当。
这是当我们创建您的视图 ， 执行布局 ， 然后绘制它们的时候。
然后我们拿起这个信息 ， 我们承诺把你的第一个框架变成光彩夺目的像素。
可以通过减少层次结构中的视图数量来影响这个阶段。
而您可以通过平整您的视图以减少使用或懒散加载在发射过程中没有显示的视图来做到这一点。
你也应该看看你的汽车布局 ， 看看你是否可以减少你所使用的约束的数量。
最后 ， 我们有了延长的阶段。
这是从第一次提交到向用户显示最终框架的应用程序特定时期。
这是当你加载我们所谈论的异步数据的时候。
现在并不是每个应用程序都有这个阶段。
但是 ， 如果你有这个阶段 ， 你的应用程序应该是互动和反应。
如果您确实有这个阶段 ， 我们只对您应该如何对待这个阶段有一般性的建议 ， 那就是了解正在发生的事情 ， 您可以通过利用 OS 标志 API 标出和测量这两个时间段之间发生的工作来做到这一点。
现在我们谈论发射是什么 ， 让我们谈论如何获得可用的测量。
在任何时候 ， iOS 设备都处于各种不同的状态和条件下 ， 这可能给发射带来巨大的差异。
所以 ， 当我们分析和比较我们的发射结果时 ， 确保我们对苹果进行比较是至关重要的 ， 因为在你做任何改变之前 ， 你如何知道你是否取得了任何进展 ， 你的发射结果是完全不可预测的 ？ 使它们可以预测的第一步是消除那些差异的来源 ， 例如网络干扰和对背景过程的干扰。
现在我们意识到这听起来有悖直觉 ， 因为这可能导致发射并不完全代表正常使用 ， 但我们想让你知道这没关系。
更重要的是要有一致的结果 ， 你可以用来评估进展。
在苹果 ， 我们一直在使用这一技术成功地检测开发过程中的倒退和降低发射时间。
然后 ， 我们使用从现场收集的遥测来验证这些性能改进。
幸运的是 ， 我们有一些关于建立清洁和一致的环境的建议。
首先 ， 重新启动你的设备。
这将清除任何不必要的状态 ， 然后让它在接下来的几分钟中安定下来 ， 清除任何启动时间工作。
你也可以通过打开飞机模式或者在代码中标出你的网络依赖关系来减少对网络的依赖。
联网可以引入相当数量的差异.
下一步是 iCloud 。
IC响亮是一个很好的功能 ， 它在背景下工作 ， 为我们的用户提供无缝的体验 ， 但在背景下的工作可能会干扰应用程序的启动。
所以 ， 在测量过程中 ， 使用不变的 iCloud 帐户使用不变的数据 ， 或完全从 iCloud 中登录。
下一步要确保在进行测量时使用应用程序的发布构建。
当然 ， 这是在测量过程中减少不必要调试代码的开销 ， 并利用编译时间优化。
最后 ， 您应该用上面提到的热发射来测量 ， 因为您的一些应用程序可能已经在内存中 ， 而其中一些系统侧服务可能已经在运行。
现在我们可以建立一些数据来测试.
创建一个具有一致性的模拟数据集非常重要 ， 您可能需要为不同类型的用户 （ 如数据数量小的用户和数据数量大的用户 ） 创建两个数据集 ， 不过 ， 在理想的情况下 ， 应用程序应该能够扩展到任何数量的数据。
这就是为什么只加载显示第一个帧所必需的数据。
现在我们已经准备好挑选一些设备了。
您应该选择对您的用户很重要的各种设备 ， 然后坚持它们的强制一致性。
一定要将您最古老的设备包含在您最古老的支持版本中。
这是因为旧设备和新设备的性能特性不同 ， 它们的 RAM 和 CPU 核数量不同。
这将确保您的启动对您的所有用户的所有设备是愉快的。
现在我们准备做一些测量。
我们可以利用新的 XCTest 来实现 XCode 11 中的应用程序发射性能.
只要有几行代码 ， XCode 就会重复发布应用程序 ， 然后提供有关它如何执行的统计结果。
我们以后再讨论这个问题。
所以 ， 现在我们讨论了什么是发射和如何测量 ， 让我们谈谈如何改进它。
当你回顾你的应用程序在代码和仪器中的启动时 ， 你应该记住这三个提示和技巧。
那就是先把你的工作最小化 ， 然后确定你的工作的优先次序 ， 最后 ， 优化你的工作。
当尽量减少工作时 ， 您应该推迟与生成第一个帧无关的任何事情。
这意味着推迟未显示视图或尚未使用的变暖前功能等内容。
您还应该避免用网络 I / O 、文件 I / O 或更多阻断主线程 ， 因为这将影响发射。
移动到背景线程。
最后 ， 您应该注意减少内存的使用。
分配和操作内存可能需要时间。
下一步 ， 确定工作的优先次序。
这就是你应该确保工作安排在正确的服务质量上的时候。
现在在 iOS 13 中 ， 我们对日程安排程序进行了一些令人兴奋的优化 ， 使您的应用程序启动得更快。
但这意味着比以往任何时候都更需要保护优先级问题 ， 通过线程传播工作。
您应该从 WW2017 中看到现代化的大中央调度用户 ， 这将深入讨论如何正确地处理并发性。
最后 ， 我们进行了优化工作。
在你将它最小化并优先排序后剩下的任何东西都应该优化。
也就是说 ， 它应该简化和限制。
例如 ， 限制只在发射过程中获取所需数据的数量 ， 或者懒散地计算所需的变量和结果。
当你这样做的时候 ， 看看你的方法和算法 ， 看看你是否可以优化它们 ， 因为你可以通过不同的结果计算或者使用不同的数据结构来获得显著的改进。
最后 ， 你应该隐藏你的资源和你的并发症。
这当然是为了减少 CPU 和内存开销 ， 做了多次不必要的工作。
所以 ， 我想把舞台交给丹 ， 丹将给你一个伟大的演示如何利用 XCode 仪器中的新的应用启动模板来理解和改进我们的应用。
谢谢你 ， 斯宾塞。
大家好 ， 我叫丹 · 索瓦达 ， 我也是苹果公司的性能工程师之一。
今天 ， 我将通过一个典型的工作流程来理解应用程序的启动 ， 并寻找最大限度地减少、优先排序和优化工作的机会 ， 以便您能够真正提供一个令人愉快的第一次用户体验。
让我们开始吧。
我今天要展示的那个应用程序叫做星际搜索。
这是我们专门为本届会议编写的一个例子应用程序。
你可以看到 ， 这是一个非常典型的 UI 表视图 ， 列出了我想象中的所有恒星。
如果你点击单元格或星星 ， 除了图片外 ， 它还显示你的描述有点模糊。
但是 ， 我们有一个问题 ， 让我们着手启动它吧。
准备好了 ， 走吧。
所以 ， 这需要一个惊人的 2 。
5 秒钟后发射 ， 不确定我能不能说得那么愉快。
所以 ， 让我们用 X代码和仪器看看我们在这方面是否有什么可以做的。
所以 ， 我们在这里有我们的 X代码搜索项目。
现在 ， 在进行任何性能相关分析之前 ， 我们应该做的一件重要事情是选择 XCode 中的配置文件方案。
这将确保 XCode 在发布模式中重新编译应用程序 ， 以便您能够利用编译器时间优化的优势。
一旦 XCode 重新编译你的应用程序, 它将在你的设备和发射仪器上安装它.
现在 ， 我们高兴地宣布 ， 从 iOS 13 或 XCode 11 开始 ， 我们现在有了 "上诉启动模板" ， 我们可以专门用于类似这样的筛选目的 ， 找出 "上诉启动" 有什么问题。
所以 ， 让我们继续 ， 双击 "上诉启动" 。
现在我们想在这里做的第一件事就是点击记录按钮。
此时 ， 仪器将自动发射我们的应用程序 - - - - 星际搜索器 ， 收集所有的度量数据、遥测数据 ， 进行分析 ， 并为所有的应用程序发射阶段创建可视化。
所以 ， 看看吧。
以紫色标记的前几个阶段是在应用程序中调用主要函数之前发生的阶段。
在绿色阶段 ， 早期阶段的这些阶段发生在您的第一个主要功能 ， 当您的应用程序完成其启动并绘制其第一个框架的 UI 。
让我们走吧 ， 扩大车道。
当我们扩展通道时 ， 您可以看到在应用程序进程中响应的所有线程的详细状态。
很明显 ， 最重要的是主线程 ， 也就是 UI 线程 ， 它负责提交用户输入和绘制您的 UI 。
让我们着手确定与我们的目的相关的路线 ， 从应用程序发射阶段开始 ， 我们的主线 ， 还有一条工人线在发射期间做了大量的工作。
那么 ， 让我们继续吧 ， 把这也搞定。
说到线程状态 - - 哦。
就这样。
谈到线程状态 ， 灰色意味着线程被阻塞 ， 意味着线程没有做任何工作。
红色的意思是它是可以运行的 ， 意思是有计划的工作要做 ， 但缺乏 CPU 的资源。
橙色的意思是它是先发制人的 ， 意思是它在做工作 ， 但被打断了 ， 而更优先的是其他竞争的工作。
最后但并非最不重要的是 ， 蓝色意味着它在运行 ， 意味着它实际上正在 CPU 核心上工作。
因此 ， 利用这些信息 ， 让我们从系统接口初始化开始 ， 分阶段地审视一下。
当我们三重点击一个阶段时 ， 我们可以突出该阶段并获得详细信息接近屏幕的下半部。
在左边 ， 您可以看到在这段时间里完成的所有工作的详细的堆栈跟踪。
在右边 ， 您可以看到聚合堆栈跟踪 ， 该跟踪列出了按 CPU 样本大小排序的所有符号。
现在注意到 ， 这个初始阶段在建立系统接口时只需要 6 毫秒。
这主要是由于染料 3 的引入和第三方应用以及其他系统层的增强带来的好处。
因此 ， 作为开发人员 ， 我们可以在不编写单行代码的情况下利用所有这些增强。
让我们继续 ， 但在我们这样做之前 ， 还有一件事情我应该在这里指出。
请注意 ， 虽然这个阶段在星际搜索器的 CPU 时钟上只花费了 6 毫秒 ， 但在墙上的时钟上却花费了 149 毫秒。
这种差异来自剖析机制本身的开销 ， 这确实给了我们很多信息和洞察力 ， 但也有其自身的成本。
所以 ， 这就是为什么区分剖面和测量是非常重要的 ， 我将在稍后解释。
进入下一阶段 ， 即静态运行时初始化。
现在注意到这个阶段花费了 375 毫秒.
现在有点太长了。
所以 ， 让我们看看。
看看详细的堆栈跟踪 ， 我们看到一个带有蓝色图标的突出符号 ， 标志着在 CPU 上的 370 毫秒的工作价值。
现在 ， 所有这些突出的符号都指示了在我们的源中声明的代码。
让我们点击它吧.
现在 ， 通过扩展堆栈跟踪 ， 它指向 SL超快日志。
现在 ， 如果一个图书馆自称为超快 ， 那就意味着有些可疑 ， 但让我们来看看。
因此 ， SL超快速测井器是一个外部框架 ， 我们已经特别导入星际搜索器 ， 以利用强大和方便的测井优势。
但是 ， 我们调用该框架的唯一位置是表视图控制器中的位置。
具体而言 ， 在 "选举" 范围内回调。
现在这个回调完全脱离了发射路径 ， 因为它只是在用户点击单元格时才被调用。
那么 ， 为什么它在发射初期甚至在调用我们的主要功能之前都要做超过 300 毫秒的工作呢 ？
通过搜索符号 ， 它指向在 SL 超级快速日志类中声明的加载方法。
现在 ， 这是一个静态的初始化程序 ， 这意味着所有这些工作都将在启动之前很早就完成 ， 然后再调用一个主要功能 ， 因为我们与它有联系。
现在 ， 删除这里的内容是 ， 理解依赖关系在您使用的框架中的影响是非常重要的。
外部图书馆和框架可能很方便 ， 而且可能很强大 ， 但费用可能很高。
因此 ， 如果这些成本证明了好处是合理的 ， 那就是巨大的。
但就我们而言 ， 发射过程中的 300 毫秒对我们的价值来说有点过头了。
所以 ， 让我们着手寻找替代办法。
在我们的情况下 ， 让我们来使用我们。
日志 ， 这是一个非常轻巧和高效的记录机制 ， 与 iOS 和其他苹果平台。
一旦我们移除了依赖关系 ， 我们就绝对需要记住另外一件事情 ， 那就是移除实际的联系。
现在 ， 由于这里的成本是用静态初始化器 ， 我们需要确保取消链接 ， 以便它不会影响我们。
就这样 ， 让我们回到我们的踪迹吧。
下一阶段是 UIKit 初始化, 在墙上时钟花费了 28 毫秒.
现在 ， 这对所有应用程序来说都是一个固定的成本。
所以 ， 除非您在 UI 应用程序中进行子类或自定义初始化工作 ， 否则我们现在可以忽略它。
那么 ， 让我们继续行动吧。
下一部分工作是您的应用程序初始化 ， 这在很大程度上是您控制的。
现在注意到大量的工作正在进行中 ， 已经用了 791 毫秒的挂钟对 "完成发射退出选择" 进行了回调。
现在太久了。
让我们看看。
因此, 这个阶段立即让我们看到了星际数据提供者类的大量工作.
它说 ， "装载恒星。
"好吧 ， 现在 ， 注意到主线上有一个巨大的阻塞 ， 这实质上是我们发射的延迟。
我们的主线被阻塞了 754 毫秒.
现在不是很好了。
让我们看看。
因此 ， 为了检查详细的状态 ， 我们应该查看事件列表。
通过查看事件列表 ， 我们注意到它被阻塞了 754 毫秒 ， 之后 ， 线程 0x12253 使它没有阻塞或可以运行。
现在 ， 这与正在做大量工作的这个工人线程相对应。
所以 ， 这里有一些关系。
现在回到主线程 ， 注意它计划在优先顺序 47 下工作。
47 个相当于用户交互 QoS 。
现在看看这个红色的会议还有很多工作要做 ， 但是它缺少 CPU 的资源。
好吧 ， 让我们弄清楚原因吧。
当我们点击工人线程时 ， 我们注意到有很多工作计划在优先事项 4 下工作。
这相当于背景 QoS.
我们在这里看到的是一种称为优先级反转的症状 ， 即给定的线程被一个比它本身更低的 QoS 或优先级的单独线程阻塞。
显然 ， 这并不理想 ， 因为它的目标仍然是发射更多。
那么 ， 让我们继续努力解决这个问题吧。
回顾过去 ， 作为这个问题核心的星际数据提供者是一个非常简单的类 ， 负责从 SQLite 数据库中获取我们星星的数据 ， 有一个带有背景 QoS 的专用发送队列 ， 并注意到这是为了确保数据采集不会与 UI 竞争。
还有两个 API 被曝光了。
一个用于异步加载数据 ， 使用此 GrandCentralDispatch 的异步原始和另一个同步 API 以同步方式加载数据。
现在 ， 我们查看了已完成的发射选项中的实际呼叫站点 ， 我们正在利用异步 API ， 但也在利用发送信号处理 ， 以确保我们在着手绘制表视图的实际第一个框架之前等待所有数据的提取。
现在 ， 如果我们要这样做 ， 我们应该使用正确的并发原始 ， 即 GCD 中的同步原始。
现在使用正确的并发原语 ， GrandCentralDispatch 将临时将主线程的优先级传播到工人线程 ， 并将其提升到不活动的用户 ， 以使其匹配。
因此 ， 在这一点上 ， 我认为我们有可能解决优先倒置问题 ， 但我在这里注意到还有一个问题。
加载星际数据同步 API 接受一系列行来加载数据.
在我们的例子中 ， 我们从 0 行到最后一行加载 ， 这基本上是一切。
现在 ， 当你考虑它时 ， 第一个帧只能适合有限数量的单元格可能在屏幕大小。
在星际搜索的情况下, 可能在 10 到 15 之间, 视设备而定.
所以 ， 让我们继续进行优化 ， 而不是加载所有内容 ， 让我们只加载前 20 行 ， 就足够同步绘制表视图的第一个帧了。
之后 ， 我们应该在背景下懒散地加载其余的内容 ， 只在发射后完成时更新表视图。
让我们继续行动吧。
回到踪迹 ， 最后但并非最不重要。
最后一个阶段是我们的第一个帧渲染。
请注意 ， 这一阶段耗时 951 毫秒 ， 时间很长 ， 考虑到这只负责进行布局工作和绘制我们的第一个框架。
现在让我们进行更深入的潜水 ， 它指向 StarTablevew控制器 ， 看看详细的堆栈跟踪 ， 我们看到了很多工作和一个 CellForRowat 回调 ， 该回调负责做单元格的布局工作。
让我们继续说下去 ， 扩大这个范围。
当我们扩展堆栈跟踪时 ， 它指出了在 CPU 上花费了 882 毫秒的星尾视图控制器的许多初始化工作。
所以 ， 在这一点上 ， 我们已经确定这在很大程度上是这里的瓶颈。
让我们看看我们的代码。
现在查看 CellforRowat 中的表视图控制器回调 ， 我们使用自定义单元格创建单元格 ， 与此同时 ， 我们进行了一个投机优化 ， 即预热和缓存 "裁剪 Vew" 的裁剪视图控制器 ， 就像我们做布局工作一样。
这是为了简化从表视图向详细视图的过渡。
但正如我们在追踪中看到的那样 ， 这并不会造成高昂的成本。
现在退一步一点 ， 当你想起来的时候 ， 详细的视图对我们的第一个框架是没有意义的。
只有当用户在单元格上拍拍时, 它才有意义.
所以 ， 让我们继续 ， 推迟这项工作。
我们应该把它推迟到什么地方呢 ？ 也许是 "选择回调" ， 当用户敲打单元格时调用了它。
因此 ， 在这个时候 ， 我们已经对星际搜索器进行了一些改进或优化。
那么 ， 让我们来重新描述一下吧。
现在有一点需要注意的是 ， 当你进行渐进式的改变时 ， 你应该在取得进展的过程中不断地重新测量和重塑形象。
这样 ， 您就可以真正理解增量变更集的确切影响。
但为了他的演示 ， 为了时间和繁荣 ， 我们实际上把所有的变化都合并成了一个。
有一点 UI 故障 ， 但我们可以立即看到我们的发射在 500 毫秒以下。
现在 ， 正如我前面说过的那样 ， 特征分析机制确实需要自己的费用。
因此 ， 为了更好地了解我们的用户将体验到什么 ， 让我们着手利用新的 XCTest API 来测试我们的发射性能。
只要有几行代码 ， 我们就可以实际将发射性能测试或任何性能测试与 XCTest 集成起来。
让我们继续吧 ， 把它踢开。
现在 ， XCTest 将做一次抛锚的发射尝试 ， 从而消除了冷射所造成的差异。
之后 ， 它将执行指定的迭代次数或默认的五次发射迭代 ， 并测量它所花费的时间。
之后 ， 它将产生一个很好的数据统计数据。
这次测试需要几分钟才能完成 ， 现在我们已经从 2 号发射了星际搜索器。
5 秒到刚刚超过 300 毫秒。
为了结束演示 ， 我想让你看看 UI 上的实际情况。
所以 ， 让我们确定我们杀了星际探索者。
那是很快的。
谢谢。
回到你身边 ， 斯宾塞。
丹 ， 谢谢你的精彩演示 ， 关于如何使用 XCode 、仪器、应用模板来提高我们的应用启动体验。
所以 ， 我们意识到 ， 在你的代码基础上 ， 你不会在代码中找到几个位置 ， 你可以用几行修好 ， 并得到如此实质性的改进。
更有可能的是 ， 你必须找到一个 5 到 10 毫秒的赢家 ， 然后把所有的都堆叠在一起。
我们想让你知道我们已经得到你的支持了。
我们已经进行了大量的 iOS 优化 ， 以改进应用程序的启动 ， 并帮助你在很少或根本没有从你那一方被采纳的情况下实现你的目标。
我特别要请几个人发言。
如上文所述 ， dyld3 将您的运行时依赖项隐藏到您的应用程序中 ， 您在演示中看到了这些应用程序 ， 这提供了巨大的改进。
还优化了日程安排 ， 以帮助确定发射期间发生的工作的优先次序。
我们还在显微镜下安装了自动布局和目标 C ， 并进行了一系列优化。
最后 ， 我们今年晚些时候对应用程序包进行了令人兴奋的修改。
我们认为 ， 总的来说 ， 这些变化应该导致你的应用有巨大的改进 ， 很少或根本没有被采纳。
所以 ， 让我们用一些技巧和技巧来总结事情 ， 如何确保你的应用程序保持愉快一旦你完成了所有的工作。
首先 ， 不要让演出成为事后的思考。
你应该从每一个错误修复的开始 ， 每一个重新因素的开始和每一个特征的开始开始开始研究和思考它。
这是因为引入回归非常容易 ， 特别是像 2 毫秒这样的回归。
问题是 ， 这些小问题加在一起构成了一个大问题 ， 如果你不立即解决这些问题 ， 就很难找到所有的问题。
要做到这一点 ， 为了检测这些倒退 ， 你应该在一段时间内计划你的应用程序的启动并定期运行测试。
这将确保您达到您的目标 ， 并且您立即知道您是否已经从该目标倒退。
你还应该看看新的 XCode 组织者 ， 它让你知道你的应用程序在这个领域是如何执行的。
在 iOS 13 中 ， 对于选择加入的用户 ， 将收集有关应用程序的功率和性能度量。
然后 ， 它们将在 24 小时内汇总 ， 并发回您的组织者 ， 您可以在那里通过软件版本和设备版本以直方图的形式查看它们。
但是 ， 如果你想对这些数据进行更多的控制 ， 你可以采用 MetriKit 。
MetriKit 允许您指定自定义的功率和性能度量.
现在和组织者一样 ， 这些数据将在 24 小时内收集和汇总 ， 然后通过应用程序中的委托方法返回给你。
从那里 ， 你可以自由地处理你认为合适的数据。
为了了解更多这方面的情况 ， 我们建议你从 W2019 中检查电池的寿命和性能。
因此 ， 总之 ， 我们希望你今天能开始理解你的应用程序在 XCode 仪器中推出的新的 "上诉模板" 。
看看你是否能找到机会来最大限度地减少、优先排序和优化你的工作。
其次 ， 尽管意图很好 ， 但并非所有的优化都能奏效 ， 比如丹在演示中提到的变暖前的消散视图控制器。
所以 ， 当你做改变时 ， 一定要衡量而不是估计你的表现。
再一次, 无意中引入倒退是很容易的.
最后 ， 你应该跟踪你在所有发展阶段的表现。
这意味着在各种设备上使用新的 XCTest 应用程序发射测量 ， 并可能将其与持续集成结合起来。
这将确保您始终向您的所有用户提供一个愉快的应用程序启动所有的设备。
欲了解更多信息 ， 请查看我们今天提到的会谈 ， 并在星期五下午有很好的休息时间。
谢谢。
掌声声响;
