大家好 我的名字Spencer Lewson 我是苹果实战队工程师
今天我非常兴奋地告诉你 如何优化应用启动
我们今天将覆盖四大题目
第一,什么是发射?不同类型发射和如何拆分子段?下一步,我们将讨论如何适当测量应用的发射
场外iOS设备可处于各种状态和条件中,而这些状态和条件可产生前后不一的发射结果
理解这些状态和测量时如何减少作用非常重要
完成后,你就可以研究使用工具剖析并理解应用寻找改善机会
最后,我们将留给你一些技巧和技巧 如何监控应用启动 时间和领域,以确保你一贯地 向所有用户提供愉快经验
程序启动程序是什么?a启动程序中断用户体验
这是什么意思?
好 准备 准备 开始
Wow上iPhone6S+启动近2
5秒,而这并不像用户期望的那样令人愉快
要知道,启动是件很重要的事 因为它常发生
在所有OS设备中 每天发生数十亿次
所以,我们做了点数整理, 并发现只要省下一毫秒, 就能省下奇特162天发射时间, 换句话说,是的,谢谢你,换句话说,这就是向火星发送火箭所需时间
但也很重要 原因多
首先,应用启动者是你的用户,应用的初始经验, 并因此应该令人愉快
现在重要的是记住,作为开发者,我们倾向于向更新设备引力
必须确保手头所见经验与客户所见经验相同,用户手掌不同OS设备并条件不同。
启动覆盖代码库的一大部分 从素量涂层到初始化 视图创建 更多
正因如此,如果你看到您的启动并不像用户期望的那样令人愉快, 这可能表示您的代码库中还有其他部分也令人愉快。
终于启动时间极强
涉及到多CPU工作 和多存储工作
所以,你应该尝试减少它 因为它影响系统性能, 当然,你的用户电池寿命
取前所讲的那些启动程序 冷启动程序 热启动程序 常被称为启动程序 但不是完全启动程序 恢复程序
重开后冷启动或应用很久没有启动
启动器应用需要从磁盘带入存储器启动系统端服务支持应用并生成过程
如你所期望,这可能需要点时间, 但幸运的是,一旦它发生一次, 你会体验热启动
在本案中,你的应用仍然需要生成, 但我们已经把应用带入存储器并启动部分系统端服务
速度会快一点 一致性会稍强一点
终于有复发
用户从家用屏幕或app切换器重入应用时发生这种情况
如你所知,应用已经启动 点,所以它会非常快
从中记住的不是混淆恢复与发布
信息信息显示, 发射速度快和喜人像履历一样快? 如何实现呢? 嗯,我们需要达到目标 实现第一个框架在四百毫秒内
于启动动画期间向用户展示像素, 启动动画完成时,应用即交互响应
第一步就是理解启动时发生的事情
启动地图
如你所知,启动通常从用户窃取主屏幕上的图标开始
接下去大约100秒内iOS将做系统边的必要工作以初始化应用
离开开发者约300毫秒创建视图,加载内容并生成第一个框架
现在这个框架不一定需要完全完整
它可以有一些位标异步加载数据, 但此时点上,你的a应用应该交互响应
以地图为例 所有瓦都还没有加载
仍可启动搜索浏览首选
接下几百毫秒后,你可显示异步加载数据并生成最终框架供用户使用
深入观察这些阶段
六相覆盖从系统初始化到应用初始化到查看创建和布局等所有内容,然后依存a
前半系统接口dild
对不熟悉者而言,动态链路加载共享库和框架
2017年,我们引入了Dyld3,为系统添加了令人振奋的优化
we're happy宣布在OS13中 带这些优化应用
表示我们正在缓存您的运行时依赖点或热发射点,这应该能大大提高速度
谢谢
带新链路者 来点新建议
充分利用这些新改进, 我们建议避免连接未使用框架, 因为这可能有隐藏成本, 稍后我们会展示给你
并推荐避免动态库加载,如DLOpen或NSBundleLoad, 因为这将失去那些通过存取缓存本能得到的胜算
最后,这意味着你应该硬连接所有依存关系, 因为它比以前更快
后半系统接口libSystemInit
初始化低级系统组件
现在这多半系统侧工作固定成本
使用开发者不需聚焦段
静态运行时间初始化
系统初始化Objective-C和Swift运行时间
泛泛地说,除非有静态初始化方法,否则应用不应该在这里做任何工作,这些方法可能在代码中出现,或更有可能从链接的架构中产生意外。
一般说来,我们不推荐静态初始化
花点时间讨论如何减少撞击
拥有使用静态初始化框架时,可考虑提前揭穿API初始化栈
但如果你必须使用静态初始化, 则会考虑从类负载移动代码, 每当发射时都引用它类初始化, 这是一种懒惰引用方式 第一次使用方法
下加UIKit初始化
系统即时激活UIApplication和UIApplicationDelege
在大多数情况下,这是系统侧工作,建立事件处理和集成系统
可您仍可有效此阶段, 或小类UIApplication或做UIApplicationDelegate初始化工
程序初始化
好东西都在这里
开发者可能会对应用启动产生最大影响
对于那些尚未在APIs中采用新UIC或以OS12或更早使用IOS者,应用Init使用这些委托回调方法
程序:用Objects解决Objects解决应用问题:用Objects解决Objects解决Objects解决Objects
程序向用户显示后,下一步方法,应用DadeBecomeAbjective:将引用
现在重要的是知道,如果你没有UISCenes,你应该创建视图控制器并用Opts完成FinishLaunching
isceen应用Init工作略微不同
现在,你仍然会得到FinishLaunch和FinishLaunch使用Objects,但当应用向用户显示时,你将得到UISEENEDERGE生命周期回调
即自然场景: 会与会议连接并选择
场景进入前台 场景成形
创建视图控制器和场景:
需要注意的是,你应该只创建视图控制器和场景: 会与Objects和Objects
常见陷阱, 并导致性能损耗 并可能无法预测的错误
不论你是否采用新的ISceenaAPIs, 我们建议本阶段基本相同
推迟无关工作,但不必执行第一个框架, 要么推入后台队列,要么完全后台工作
iscenes使用后,你还可以做一件事, 保证资源共享
这样做当然是为了减少做不必要多工的间接费用
深入了解UISCenes,
下框架转换阶段
相对直截了当
即当我们创建视图执行布局并绘制时
然后我们取信息,我们承诺并实现你的第一个框架 美美闪闪像素
通过减少层次视图数可影响此阶段
通过平整视图少用或懒散加载视图实现这一点,这些视图在发射时不显示
并查看汽车布局 看能不能减少约束数
归根结底,我们有扩展阶段
a-特定段段从首次承接到向用户显示form frame
即时加载我们讨论的异步数据
并非每个应用都具有这一阶段
但如果你真的有这个阶段,应用应该是交互响应式的
使用OS标牌API系统标出并测量这两个时段间所发生工作,可以实现这一点。
现在,我们谈什么启动, 让我们谈如何获取可用测量
iOS设备在任何特定时间处于各种状态和条件之下,这可能给发射带来重大偏差
分析比较启动结果时,关键是要保证我们做苹果对应用比较,因为你如何知道在修改前你是否取得任何进展?启动结果完全无法预测?实现预测的第一步是消除差异源,例如网络干扰和背景进程干扰
现在我们意识到这听起来反直觉, 因为这可能导致发射 不完全代表常用性,
更重要的是有一致性结果 你可以评价进度
苹果公司使用这一技术成功检测开发期间回归并驱动启动时间
并使用从现场收集的遥测技术验证性能提高
幸运的是,我们有一些技巧 搭建干净和持续环境
先重开设备
这会消除不必要的状态, 并让它在接下来几分钟内安定下来 清理启动时工作
也可以通过开机模式或标出网络代码依赖度来减少对网络依赖度
网络化可产生相当大差异
下位为iCloud
ICloud是一个伟大的特征,后台工作向用户传递无缝经验,但后台工作可干扰app启动
测量期间使用不变iClud账号不改变数据或完全注销iClud
下一个确定使用发布构建应用
以降低测量期间不必要调试代码的间接并使用编译时间优化
最后,你应该用热启动量测算,前文提到,更一致,因为部分应用可能已经在存储中,而部分系统端服务可能已经在运行中。
现在我们可以搭建数据测试
创建自定义数据集很重要,它一致性强, 你可能需要一对数数据集 面向不同类型的用户,例如数据量小用户和数据量大用户, 不过,在理想状态下,应用应用应该能向量数据缩放
正因如此 只加载数据显示第一个框架
准备选择设备
选择对用户重要的各种设备 并紧紧紧紧紧紧紧紧紧紧紧紧紧紧紧紧紧紧
一定要包含最老设备 支持最老发布
这是因为性能特征看老式设备与新式设备不同,这些设备内存和CPU核心量不同。
这将确保您的启动令所有用户都欢乐
现在我们准备做点测量
XCTest新版 XCode11应用Launce性能
单用几行代码 Xcode将多次启动应用 并随后提供统计结果
待会再谈
现在,我们讨论什么启动和如何测量它, 让我们谈点如何改善它
检视应用代码和工具启动时 记住这三个技巧
即先将工作最小化,然后确定工作优先级,最后优化工作
最小化工作时,应推迟与生成第一个框架无关之事
表示延迟事物像 未显示视图或升温前特征 尚未使用
避免阻塞主线线, 或网络I/O文件I/O文件或更多, 因为这会影响启动 。
移动到后台线程
归根结底,你应该小心减少内存用法
分配和操纵内存需要时间
下位优先作业
即应保证工作定时正确质量服务
OS 13中,我们对调度器做了一些激动人心的优化 使应用发射速度更快
表示维护优先题比任何时候都重要 跨线传播工作
大中央调度现代化自2017WW深入处理并发问题
最后,我们优化工作
所遗留的一切 后你最小化 并优先排序它应该优化
也就是说它应该简化和限制
举例说,限制数据量只取启动时需要的数据或懒惰计算需要的变量和结果
做这个时, 查看你的方法算法 并研究你是否可以优化这些算法, 因为通过以不同方式计算结果或使用不同数据结构 可以得到显著改进
最后,你应该缓存你的资源 和你的复杂问题
当然,这是通过多工多工减少CPU和内存管理
将台交到丹手中 丹会向您展示 如何使用Xcode工具中新启动模版 理解并改进应用
谢谢你 Spencer
大家好,我叫丹泽达 也是苹果公司性能工程师
今天我将浏览典型工作流 理解应用启动并寻找机会 最小化优先化优化工作
开始吧
程序我今天将要展示 被称为星搜
实例应用 我们特地为此会话写
如你所见 UI表视图非常典型 列出我所有虚幻恒星
点击单元格或恒星时,会显示小描述除图片外还模糊
然而,我们有一个问题,让我们启动它
准备上
取奇2
5秒启动,不确定我能否称之为令人愉快
使用Xcode工具测试
这儿有Xcode星搜项目
重点是 选择Xcode剖面图
Xcode重编解码模式,以便你利用编译器时间优化的好处
Xcode重编译应用后,它会安装到设备上并启动工具上
as OS 13或Xcode 11,我们现在有AppLaunchTemplate
开始双击AppLaunch
现在首先我们要做的是按下记录按钮
此时,工具自动启动StarSearker应用程序,收集所有度量数据,遥测数据,分析数据并创建可视化应用所有启动阶段
边看边看
前几步标注紫色
绿色阶段,这些初级阶段 发生于你主函数之首, 应用完成启动并绘制UI的第一个框架
继续拓展小道
当我们扩展通道时,你可以看到所有线程的详细状态,这些线程响应应用过程
最重要的是主线或UI线程,由它负责传递用户输入并绘制UI
开始启动阶段,主线 多一条工线 启动时做大量工作
let's go
说到线程状态-ops
象那样
说到线状状态 灰色表示它被阻塞 表示线条不工作
红色表示它可持久化 表示工作定时完成 但没有CPU资源
橙色表示它先发制人 表示它工作但中断 支持高优先级的其他竞技
最后但非最不重要的是,蓝表示它运行, 意指它实战CPU核心工作
有了信息后,我们先从系统接口初始化开始逐级查看
三击相位时,我们可以突出相位并获取详细信息面向屏幕底部半部
左侧可见详细栈迹 期间所有作品
右侧可见汇总栈迹表,它按CPU样本大小数排列所有符号
注意初始阶段建立系统接口时只花6毫秒
主要原因是Dyld3引进和第三方应用以及其他系统层增强
作为开发者,我们可以利用所有这些增强而不写单行代码
继续前行前,我还要指出一件事
注意这个阶段只花六毫秒 CPU星搜时钟 花149毫秒
偏差出自剖析机制本身的间接作用,它的确给我们很多资料和洞察力,但有自己的代价。
正因如此 用测量法辨别非常重要 稍后我会解释更多
下阶段静态运行启动
注意这个阶段耗时 惊人375毫秒
现在有点太长
容我们查一查
查看详细栈迹时,我们看到高亮符号,蓝图标标注370毫秒值CPU工作
全部高亮符号表示代码 源码内声明
点击它
通过扩展栈跟踪,它指向SLSUPERFastLogger
现在,如果图书馆称自己超快, 表示有些疑惑,但让我们来看看
sLSUPERFastLogger是一个外部框架,我们专门输入星搜索器以获取强权方便日志的好处
唯一引用框架的地方是表视图控制器
具体说来 选择RowAt回调
回调完全超出发射路径, 因为它只在用户窃听手机时使用
why is it doing 超过300毫秒的工作启动时 甚至在引用主函数前
通过搜索符号,它指向SL超快滚动类内宣布加载法
静态初始化程序 即所有工作都提前启动 才能引用主函数
现在,这里的取舍是 理解依存关系对框架的影响非常重要
外部图书馆和框架可能方便并可能强健,但代价可能很高。
所以,如果这些代价证明利益合理,大局
实战中300毫秒 略微超出值
继续寻找替代方法
以我们为例,用os
日志,这是一个轻高效日志机制 与iOS系统以及其他苹果平台并发
等我们消除依赖性后, 还有一个事我们绝对需要记住去做, 即消除实际关联性
成本由静态初始化器组成 我们需要确保消除关联 以免它影响我们
带回追踪
下一个阶段是UIKit初始化,它取时钟28毫秒
现在这几乎是一个固定成本 所有应用
非子类UI应用或自定义初始化UIApplicteDelegte
继续前行
下块工作就是你应用初始化 基本由你控制
注意有大堆工作 与FinishLaunchingObjects回调, 取791毫秒墙时钟
时间长
先看一看
即刻指针StarDataProvider类的大量工作
上载星
注意主线有巨大的阻塞 基本上就是延迟发射
主线堵塞754毫秒
现在这可不妙
先看一看
为了检查详细状态, 我们应该查看事件列表
通过查看事件列表,我们发现它阻塞754毫秒, 后经0x12253线解阻或调试
和工人线对称 做大量工作
并存关系
重回主线 注意它定时优先度47
47等量用户交互QOS
现在看这些红色会议有很多工作要做, 但它缺少CPU资源
好,让我们弄清楚原因
点工线时,我们注意到 有许多工作排在优先级4
eqs等值后台Qos
我们实际看到的是优先级倒置的症状, 给定线程被单线阻塞, 单线程比自身优先级低或优先级
很明显,这不是理想, 因为它仍然目标启动比它应该更多
所以,让我们继续 并试图修复
回想StarDataProvider问题的核心,它是一个非常简单类,负责从SQLite数据库获取数据,并配有带后台QOS专用调度队列,并注意这是为了确保数据采集不与UI竞争
并有2API曝光
异步加载数据使用大中分片非同步原语
finishLaunchingObjects内的实际调用站点,我们正利用异步API,但也利用发送模式确保等待所有数据取出后再开始绘制表视图实际第一框架
if we're going to do this, we should使用正确的并发原语, 即GCCD同步原语
GrandCentralDispatch使用正确并发原语暂时向工人线传播主线优先级并提升为非用户以匹配
此时此刻,我想我们有潜力解决优先倒置问题, 但我在这里注意到还有一个问题
加载StarDataSyncAPI接受数行加载数据
以我们为例,我们从0行加载到最最后一行, 基本即一切
现在想一想,第一个框架只能适配有限数细胞,这些细胞可能处于屏幕尺寸上。
以星搜机为例 视设备而定 约10到15
先加载前20行, 以同步方式绘制表视图的第一个框架
之后,我们应隐蔽地加载所有剩余部分,仅在启动后完成更新表视图
继续前行
回溯跟踪,最后但并非最不重要
上阶段为首框架绘制
注意这个阶段需要951毫秒, 时间很长, 认为这只负责布局制作
深入下潜 指向星表管理员 并查看详细的栈迹 我们看到大量工作
继续拓展
当我们扩展栈迹时,它指针我们为StarDelitView控制器做大量初始化工作,共882毫秒
此时点,我们已经鉴别出 几乎就是这里的瓶颈
让我们看看我们的代码
查看CellforRowAt回调表视图控制器时,我们使用定制单元格创建单元格,并同时,我们像布局工作一样,将预热并缓存DreativeView管理员
期望简化从表视图向详细视图过渡
可我们从迹迹中看到,这并不产生高成本
退后一点,想一想 详细视图对第一个框架不完全合情合理
只有当用户窃听手机时才有意义
继续延后工作
区域选择回调 用户窃听手机时使用回调
此时点,我们已经对星搜索器 做了数大增强或优化
开始重构吧
需要注意的一件事是,当你做增量修改时,你应持续重度和重定位并进
那样,你就能实际理解增量修改集的确切作用
但看在他的演示上, 我们所有变化都归为一 为了时间和兴旺
UI小故障,但我们能立即看到 我们的发射量低于500毫秒
现在,正如我早些时候所说,剖析机制本身的确要付出代价。
深入理解用户体验后, 使用新XCTestAPI测试测量测试内启动性能
光用几行代码, 我们就能把发射性能测试或性能测试 和XCTest综合
开始开工吧
此时点 XCTest将做一次推送启动尝试 消除冷送时产生的差分
后,它将执行规定数迭代或默认五迭代启动并测量时间
之后,它将生成一流数据统计
测试需要几分钟完成, 现在我们从2开始启动星搜
5秒到刚超过300毫秒
并打包演示文集,我想向大家展示UI上这个长相
let's确认我们杀星搜
速度很快
谢谢
返回你,斯宾塞
Thanks, Dan, for asce演示使用Xcode工具应用Template提高应用启动经验
所以,我们意识到,在你代码基础中,你无法在代码中找到几小段位子, 你可以用几行修复并大有改进
更有可能你不得不 发现5到10毫秒 并堆积所有那些
我们想通知你我们支持你
iOS优化数吨 提高应用启动率 帮助你实现目标
特别想打几通电话
前文提到,dield3为应用带缓存运行时依赖性
调度器还优化帮助优先处理启动期间发生的工作
我们还把自布局和Objective-C置于显微镜下并在那里做了数大优化
终于,我们今年晚些时候对应用打包有令人振奋的修改
完全这些修改应大有改进应用 微信免应用
总结一下一些技巧和技巧 如何确保应用保持愉快 一旦你完成所有工作
先别让性能演进后想
开始研究它 并思考它 在每个错误修复的起始点 在每个重构因素的起始点 和每个特征的起始点
因为它极易引入回归法, 特别是像2毫秒这样的小回归法
问题在于这些小问题加在一起大问题, 如果你不立即解决它们, 很难全部找到
并定期运行测试
保证你实现目标 并立即知道从目标回归
并查看新Xcode组织者,使你了解a
OS 13中,用户选择使用时,将收集应用电量和性能度量
24小时汇总并发回组织者,通过软件版本和设备版本以直方图形式查看
取MetricKit
Metrikit允许你自定义功率和性能度量
和组织者一样,这些数据将收集并汇总24小时并发回应用中委托法
从那里你可自由处理数据
了解更多这方面的知识,我们建议你检查WW2019提高电池寿命和性能
简言之,我们希望你今天开始理解应用启动时使用Xcode工具中的ApplauchTemplate
看你能不能找到机会 最小化优先化优化工作
下一步,虽然用意良好,但并非所有优化都解决,例如丹在演示中处理的预置详细View控制器
确定度量性能 而不是估计性能
再一次,很容易无意地引入回归
归根结底,你应该跟踪你在所有开发阶段的性能
意指使用新XCTest应用发射测量各种设备并可能与连续集成
这将保证你持续向所有用户提供可喜app启动
详情请查看我们今天引用的会谈,周五下午休息愉快。
谢谢
[掌声]
