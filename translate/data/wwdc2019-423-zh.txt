大家好,我叫斯宾塞·卢森 我是苹果公司表演团队的工程师
今天我非常兴奋地告诉你 你怎样才能优化应用软件的启动
我们今天将讨论这四个主要议题。
首先,什么是发射?什么是不同种类的发射?我们如何把它们分成不同的子阶段?接下来,我们将讨论如何适当测量应用软件的发射。
在外地,iOS装置可能处于各种不同的状态和条件,而这些状态和条件可能产生不一致的发射结果。
所以,重要的是要了解这些状态 以及如何在进行测量时 减少它们的影响。
一旦你这样做了,你就可以看看如何使用工具 来描述和理解你的应用程序 来寻找机会来改进它。
最后,我们会给你一些秘诀和技巧 关于如何在一段时间和实地 监控应用软件的启动 以确保你始终不渝地 将愉快的经验传递给所有用户
那么,我所说的那个App的启动是什么?App的启动是一个用户经验中断。
这是什么意思?
好了 准备 准备 开始 开始 Okay, ready, set, go.
哇,在iPhone 6S Plus上, 发射花了近2。
5秒,这不像我们的用户所期望的那么令人愉快。
你知道,这真的很重要 发射是令人愉快的, 因为它经常发生。
事实上,在所有的iOS设备中, 它每天发生数十亿次。
所以,我们做了一些数字紧缩, 我们发现,只要每次发射只节省一毫秒, 我们就能节省一个惊人的162天的发射时间, 换句话说,是的,谢谢你,换句话说, 这就是向火星发射火箭所需的时间。
但出于其他原因,这也很重要。
首先,你的应用程序的启动 是你的用户, 第一次体验你的应用程序, 因此,它应该是令人愉快的。
现在重要的是要记住,作为开发者,我们倾向于向较新的设备引力。
所以,重要的是要确保你手上看到的经验 和客户,你的用户一样 拥有不同的iOS设备 在不同的条件下。
此外,发射覆盖了你代码基础的一大部分, 从开源涂层, 初始化, 查看创造, 以及更多。
因此,如果你发现你的发射 并不像用户预期的那样令人愉快, 这可能说明你的代码基础的其他部分 也是令人愉快的。
最后,发射时间是电话非常紧张的时刻。
涉及到很多CPU工作 和许多记忆工作。
所以,你应该尝试减少这个影响 因为它影响系统性能, 当然,你的用户的电池寿命。
所以,让我们来看看我之前提到的那些发射, 有冷的发射,温暖的发射, 通常被称为发射的东西, 但不是相当的发射, 简历。
冷电在重新启动后发生,或者您的应用程序已很长时间没有启动。
为了安装启动器, 我们需要把它从磁盘带入存储器, 启动系统侧服务, 支持您的应用程序, 然后生成您的进程 。
正如你预期的,这可能需要一点时间, 但幸运的是,一旦它发生一次, 你会经历一个温暖的发射。
在这种情况下,你的应用程序仍然需要产卵, 但我们已经把你的应用程序带回了记忆, 并开始了一些系统方面的服务。
因此,这将更快一点,更加一致一点。
最后,还有那份履历
当用户从主屏幕或应用程序切换器重新输入您的应用程序时, 就会发生这种情况 。
正如你所知,应用程序已经启动 此时此刻,所以它会非常快。
你需要记住的是,不要在测量时 将履历和发射混为一谈。
因此,根据这个信息,如果发射的速度和喜悦程度都和简历一样快,那会不会更好呢?我们如何做到这一点?我们需要达到将第一个框架在400毫秒之内的目标。
这样,在启动动画时,我们向用户展示了像素, 在启动动画完成时, 你的应用程序是互动的,反应灵敏的。
这样做的第一步是了解发射期间发生的情况。
那么,让我们发射地图。
如你所知,发射通常从用户在主屏幕上窃听您的图标开始。
然后在接下来的100秒左右 iOS将做必要的系统边工作 以便启动你的应用程序
这样,您作为开发商, 大约300毫秒的时间来创建您的观点, 装入您的内容, 并生成您的第一个框架 。
现在这个框架不一定需要完全完成。
它可以有一些占位符 用于不同步装入数据, 但此时此刻, 您的应用程序应该具有互动性和响应性 。
因此,就地图而言,所有的瓷砖还没有上膛。
您仍然可以开始搜索并浏览您最喜欢的内容 。
然后在接下来的几百毫秒内, 您可以显示无序装入的数据, 并为您的用户生成最终框架 。
让我们仔细看看这些阶段。
这六个阶段涵盖从系统初始化到应用初始化到查看创建和布局,然后取决于你的应用程序,可能是一个对数据进行非同步装入的阶段,即延长的阶段。
系统接口的前半部分是断裂的。
对于你们中不熟悉的人来说, 一个动态的链接载荷着你们共享的图书馆和框架。
2017年,我们引进了3号, 给系统增添了令人兴奋的优化。
我们很高兴地宣布 在iOS 13中, 我们把这些优化 带到你的应用程序。
也就是说,我们现在正在拖延你们的运行时间依赖,或进行温暖的发射,这应该能大大加快速度。
谢谢
现在有了一个新的链接, 产生了一些新的建议。
为了充分利用这些新的改进,我们建议你避免将未使用的框架联系起来,因为这可能会有隐藏的费用,我们稍后会给你们看。
我们还建议你避免图书馆的动态负荷,例如DL Open或NSBundendleLoad, 因为这将失去那些你本可以从你的缓存中得到的赢家。
最后,这意味着,你应该 很难连接 你所有的依附关系, 因为现在它甚至比以前更快。
系统接口的后半部分是 libSystemInit。
这是我们在您应用程序中初始化低级别系统组件的时候。 NAME OF TRANSLATORS
现在,这主要是有固定成本的全系统工作。
所以,使用开发商 不需要专注于部分。
现在我们有静态运行时间初始化。
这是当系统初始化 您的目标- C 和 Swift 运行时间 。
一般来说,你的应用程序不应该在这里做任何工作, 除非你有静态初始化方法, 这些方法可能存在于您的代码中, 或者更有可能, 从您连接的框架中产生一个惊喜。
一般来说 我们不建议静态初始化
所以,让我们花点时间谈谈如何减少其影响。
如果您拥有一个使用静态初始化的框架, 请考虑让 API 提前初始化您的堆叠 。
但如果您必须使用静态初始化, 请考虑将代码移出班级负载, 每当发射时, 都使用该代码进行分类初始化, 这是第一次在班级中使用方法时, 懒惰地引用 。
下一个是UIKit初始化。
这是当系统即时 使你的UIApplication 和UIApplicationDelegate。
在大多数情况下,这是系统方面的工作,建立事件处理和与系统整合。
但是,如果您在 UIApplication 子类下进行应用或者在 UIApplicationDeleging 初始化器中做任何工作,您仍然可以影响这个阶段。
现在我们有应用程序初始化。
这里就是好东西所在的地方
这是您作为开发者 可能对您的应用程序的启动 产生最大影响的地方。
对于那些尚未在API中采用新的UIC或针对iOS 12或更早的iOS 12或更早采用Applic Init方法的人来说,应用 Init再次使用这些代表回调方法。
应用程序 : 将用 options 和 applications 完成 Launch 和 applications : 是否用 options 完成 Launch 。
您的应用程序向用户显示时, 将引用其他方法, 应用程序“ 已经呈现积极性 ” 。
现在重要的是要知道,如果你没有UIScenes, 你应该创建您的视图控制器, 并且用Options来完成 Finish Launching。
那是因为UISCene, 应用 Init 工作有点不同。
现在,你仍然会得到 完成 Launch and did Finish Launch with options, 完成与Options的匹配, 但是当您的应用程序被显示给用户时, 您将会得到 UISEDEGE 生命周期回调 。
这些当然是场景:将与有选择的会商联系。
场景将进入地面, 场景已经变得活跃。
您应该创建您的视图控制器, 和场景: 将会与其它选项相会 。
重要的是要指出,你应该只 创建您的视图控制器, 和场景: 将连接到与选项的相会, 以及,同样, 并完成了与选项的匹配。
通常的陷阱,当然, 导致性能损失, 以及,可能, 无法预测的错误 在你的代码基数。
无论你是否采纳了新的UISCene API, 我们对这个阶段的建议基本相同。
您应该推迟任何无关的工作, 但不必将您的第一个框架投入使用, 要么将其推到背景队列, 要么在稍后完全完成 。
如果你确实采用了UIScenes, 你可以做一件事, 这是确保你 分享你的资源 在你的场景之间。
当然,这样做是为了减少从事任何不必要的多次工作的间接费用。
若要更多了解UIScenes, 请从本周早些时候开始,
接下来是第一个框架转换阶段。
现在,这是相对直截了当的。
这是当我们创建您的观点, 执行布局, 然后绘制它们 。
然后我们把这些信息, 我们承诺 并把你的第一个框架 变成漂亮,闪亮的像素。
您可通过减少您的等级体系中的观点数量来影响这个阶段 。
并且通过平整您的观点 来降低您的观点 使用更少的,或者通过懒惰地装入在发射时没有显示的视图,就可以做到这一点。
您也应该查看您的汽车布局,看看您能否减少您使用的限制数量 。
最后,我们进入了延长阶段。
这是从您第一次承诺到您向用户显示最终框架的应用程序特定时期 。
这就是你装载我们讨论过的 零星数据的时候
现在不是每个应用程序都有这个阶段。
但如果你真的有这个阶段, 你的应用程序应该具有互动性和反应性。
如果你确实处于这一阶段,我们只有关于你应该如何对待它的一般建议,这就是了解正在发生的情况,而你可以利用OS标牌API来做这一点,从而标出和衡量这两个时期之间的工作。
既然我们谈论了什么是发射, 让我们来谈谈如何获得可用的测量数据。
在任何特定时间,iOS装置处于各种不同的状态和条件之下,这可能给发射造成很大的差异。
所以,当我们在分析和比较我们的发射结果时, 关键是要确保我们进行苹果对苹果的比较, 因为如果在你做出任何改变之前,你怎么知道你是否在取得任何进展, 你的发射结果是完全无法预测的? 使发射结果可以预测的第一步是消除这些差异的来源, 比如网络干扰和背景过程的干扰。
现在我们意识到,这听起来是反直觉的, 因为这可能导致发射 并不完全代表正常使用, 但我们想告诉你,这没关系。
更重要的是要有一致的结果 来评估进展
在苹果公司,我们一直在使用这种技术 成功地探测到开发过程中的回归 并击落发射时间
然后,我们通过使用从实地收集的遥测方法来验证这些改进性能的情况。
幸运的是,我们有一些关于建立这种清洁和连贯的环境的建议。
首先,重新启动你的装置
这将清除任何不必要的状态, 然后让它在接下来的几分钟里安顿下来 来清理任何启动时间的工作。
您也可以通过打开飞机模式或者在代码上标记网络依赖性来减少对网络的依赖性。
建立网络可以产生相当大差异。
下一个是iCloud。
ICloud是一个伟大的特征,在背景中发挥作用,向我们的用户提供无缝的经验,但背景中的工作会干扰应用程序的启动。
所以,在测量期间,使用不改变的iCloud账户 与不改变的数据, 或完全退出iCloud。
下一步一定要在进行测量时使用应用软件的发布结构。
当然,这是为了减少测量期间不必要调试代码的间接费用,并利用汇编的时间优化。
最后,你应该用温暖的发射来衡量,正如前面提到的那样,温暖的发射更加一致,因为你的一些应用可能已经在记忆中,而有些系统方面的服务可能已经在运行中。
现在我们可以设置一些数据来测试。
重要的是要创建一个一致的模拟数据集, 并且你可能需要一对夫妇的数据集, 供不同类型的用户使用, 比如数据量小的用户和数据量大的用户, 但是,在理想的情况下, 你的应用程序应该能够 推广到任何数量的数据。
这就是为什么只装载显示第一个框架所需的数据。
现在我们准备挑选一些装置了
您应该选择对您的用户很重要的各种装置,然后坚持其强制一致性。
一定要包括你最古老的装置 用于支持最古老的释放
这是因为性能特征在旧装置和新装置之间不同,前者有不同数量的内存和CPU核心。
这将确保您的发射 令所有用户 在其所有设备上都感到愉快。
现在我们准备进行一些测量
我们可以利用新的XCTest 来应用Xcode 11的Launce性能。
只要几行代码, Xcode 会反复启动您的应用程序, 然后提供它是如何运行的统计结果 。
我们以后再谈这个
所以,我们现在讨论了什么是发射 以及如何测量它, 让我们来谈谈如何改进它。
当你在审查应用软件的启动时 不管是在代码上还是在仪器上 你都应该记住这三点小把戏
这是为了首先尽量减少你们的工作,然后确定你们工作的轻重缓急,最后,优化你们的工作。
当最小化工作时, 您应该推迟任何与生成第一个框架无关的东西 。
这意味着推迟一些东西,如尚未使用的未淡化观点或升温前特征。
您也应该避免堵住主线, 无论是网络 I/ O, 文件 I/ O, 还是更多, 因为这会影响发射 。
移动到背景线 。
最后,你应该小心减少记忆的使用。
分配和操控记忆需要时间。
接下来,优先安排你们的工作。
这是你应该确保工作安排达到适当服务质量的时候。
现在在iOS 13, 我们已经做了一些令人兴奋的优化 对调度器 使你的应用程序更快的启动。
但这意味着维护优先议题比以往更加关键 将工作传播到各行各业。
您应该看看2017年WWW的 现代化大中央调度使用量, 深入了解如何正确处理通货问题。
最后,我们优化了工作。
在你将它降到最低 并排出优先级之后 留下的一切 都应该被优化
这就是说,它应当简化和限制。
例如,限制您在发射时只获取所需的数据数量,或者不固定地计算您需要的任何变量和结果。
当你这样做的时候, 看一下你的方法和算法, 看看你能不能优化它们, 因为通过不同的计算结果或者使用不同的数据结构, 你可以得到显著的改进。
最后,你应该积累你的资源和你的并发症。
当然,这样做是为了减少CPU和记忆管理费用,不必要地多次工作。
所以,我想把舞台交给丹, 丹将给你们一个精彩的演示 如何使用Xcode文书中的新的 App 发射模板 来理解和改进我们的应用程序的发射。
谢谢你,斯宾塞
嗨,大家好,我叫丹·索瓦达 我也是苹果公司的一个表演工程师
今天我将浏览一个典型的工作流程, 来理解您的应用程序的启动, 并寻找机会, 尽量减少、优先排序和优化工作, 这样你就能真正提供 愉快的首个用户经验。
所以,让我们开始吧。
我今天将要展示的应用程序 叫做星际搜索器
这是我们专门为这届会议 写的一个例子应用程序。
正如你所看到的,这是一个非常典型的 UI 表格视图 列出我所有想象中的恒星。
如果您单击单元格或恒星,它会显示一个模糊的描述,除了图片之外。
然而,我们有一个问题,让我们开始吧。
准备,去。
所以,这花了一个惊人的2。
5秒后发射 不确定我能不能称它为"令人愉快"
所以,让我们用X代码和工具 看看我们能不能做点什么。
所以,我们这里有我们的X代码项目 为星探搜索者。
现在,在做任何与业绩有关的分析之前,我们必须做的一件重要的事情就是选择Xcode的剖析方案。
这将确保 X code 在发布模式下将您的应用程序重新编码, 这样您就可以利用编译器时间优化的优势 。
一旦 Xcode 将您的应用程序重新编码, 它将安装在您的设备和发射仪器上。
现在,我们高兴地宣布,从 iOS 13,或 Xcode 11, 我们现在有AppLaunchTemplate, 我们可以专门用来 处理这种分类, 找出AppLaunch有什么问题。
让我们双击AppLaunch。
现在我们首先要做的就是按下记录按钮。
此时此刻,仪器将自动发射星星搜索器,我们的应用程序, 收集所有测量数据,遥测数据,分析数据, 并为所有应用发射阶段创造可视化。
所以,看一看。
以紫色标注的前几个阶段是您在应用程序中援引您主要功能之前的阶段 。
在绿色阶段,这些早期阶段发生在您主要功能的第一阶段, 即您的应用程序完成启动, 并在 UI 中绘制第一个框架 。
让我们继续前进,扩大车道。
当我们扩大车道时,你可以看到 所有在应用软件过程中反应的线条的详细状态。
显然,最重要的一条是主线,或称为UI线,负责提供用户输入和绘制您的UI。
让我们先把切合我们目的的车道固定下来, 首先是应用的发射阶段, 我们的主线, 还有一条工人线, 在发射过程中做了大量的工作。
所以,让我们继续前进 并把这个下来,太。
说到线状状态--哦,哦。
像这样。
说到线状状态,灰色意味着它被堵住了, 这意味着线条没有做任何工作。
红色的意思是它是可操作的, 意味着有预定要完成的工作, 但缺少CPU的资源。
橙色的意思是它先发制人, 意思是它正在工作,但被打断了, 支持了其他竞争工作, 后者具有更高的优先级。
最后但并非最不重要的一点是,蓝色意味着它正在运行, 这意味着它实际上在做CPU核心的工作。
因此,有了这些信息,让我们从系统接口初始化开始, 开始一个阶段来审视一下。
当我们三击一个阶段时,我们可以突出该阶段,并在屏幕下半部获得详细信息。
在左边,你可以看到这个时期 所完成的所有工作 的详细的堆放痕迹。
在右侧,您可以看到一个汇总的堆叠跟踪, 它列出所有按 CPU 样本大小编号排序的符号 。
现在请注意,这个初始阶段在建立系统接口时只用了6毫秒。
这主要是由于除其他系统层强化外,还得益于Dyld3引进和第三方应用的好处。
因此,作为开发者,我们可以利用所有这些改进,而不必写出单行代码。
让我们继续前进,但在我们这样做之前, 还有一件事我应该指出在这里。
请注意,虽然这一阶段只花了6毫秒用于搜索星体的CPU时钟,却花了149毫秒用于壁钟。
这种差异来自特征分析机制本身的间接费用,它确实为我们提供了许多信息和洞察力,但有自己的成本。
所以,这就是为什么用测量法来区分特征分析非常重要的原因, 我稍后将对此作更多解释。
进入下一阶段,即静态运行启动阶段。
现在注意到这个阶段 花了惊人的375毫秒
现在有点太长了
所以,让我们来看看。
我们看到一个突出的符号 蓝色的标志 370毫秒值的 CPU工作价值。
现在所有这些突出的符号 都表示代码 在我们的源代码中已经申报。
让我们点击它。
现在,通过扩展书架的追踪, 它指向我们的SLSuperfast Loggger。
现在,如果图书馆称自己为超级快, 这就意味着有些可疑, 但是让我们来看看。
所以,SLSuperfast Lougger是一个外部框架, 我们专门将它输入星际搜索器, 以便从强大和方便的伐木中获益。
然而,我们唯一援引这一框架的地方是在表视图控制器内。
具体来说,在SelectRowAt的回调中
现在,这个回调完全脱离了发射路径, 因为只有在用户窃听一个细胞时,它才会被引用。
那么,为什么它在早期发射时,甚至在我们的主要功能被援引之前, 还要做300毫秒的工作呢?让我们来调查一下。
通过搜索符号,它指向了我们 在SL超级快车牌类中宣布的加载方法。
现在,这是一个静态初始化器, 意思是所有这些工作将在发射初期完成, 然后再援引主要功能, 因为我们与它有联系。
现在,这里的取舍是, 重要的是要理解 你依赖性的影响, 在你使用的框架中。
外部图书馆和框架可能方便,可能有力,但费用可能很高。
因此,如果这些代价证明好处是正当的,那么这些代价是巨大的。
但就我们的情况而言,300毫秒的发射时间 与它的价值相比是有点过头了。
所以,让我们继续寻找其他选择。
以我们为例,让我们用OS。
日志,这是一个非常轻巧高效的伐木机制, 与iOS以及其他苹果平台相匹配。
现在,一旦我们解除了依赖关系, 还有一件事我们绝对需要记住去做, 就是去掉实际的联系。
因为这里的费用是静态初始化器, 我们需要确保消除联系, 以免影响我们。
因此,让我们回到我们的踪迹。
下一阶段是UIKit初始化,在墙钟上花了28毫秒的时间。
现在,这几乎是所有申请的固定费用。
所以,除非您在UIApplicationDelegate中 使用小类UI应用程序或做定制初始化工作, 否则我们现在可以忽略它了。
所以,让我们继续前进。
接下来的工程是您的应用程序初始化, 这几乎是你所能控制的。
现在请注意,在Finish Launching withObjects的回响下, 大量的工作正在进行中, 这在墙上的钟上花费了791毫秒。
现在,这是非常长的。
让我们来看看。
因此,这个阶段立即指向我们 在StarDataProvider 类的大量工作。
上面写着"装满星星"
"好吧,现在,请注意 主线有巨大的阻塞, 这基本上是一个延迟 我们的发射。
我们的主线堵住了754毫秒
这可不妙
让我们来看看。
因此,为了检查详细的状态, 我们应该看看事件清单。
通过查看事件清单,我们注意到它被封锁了754毫秒, 之后,它被第 0x12253号线打开, 或变得可以运行。
现在,这和这个工人的线相对应, 他们做了很多工作。
所以,这里有些关系。
现在回到主线 注意它预定在47号优先线工作
47等于用户交互式QOS。
现在看看这些红色的会议 有很多工作要做, 但它缺乏CPU的资源。
好吧,让我们弄清楚为什么。
当我们点击工人线时,我们注意到,在优先4点,有许多工作要做。
这相当于背景 QoS 。
我们实际上看到的是一个被称为优先倒置的症状, 特定线索被一条单独的线索堵住了, 这条线索比它本身的优先度低, 或比它本身的优先度低。
显然,这不是理想的, 因为它仍然旨在发射 比它应该发射的更多。
所以,让我们继续 并试图解决这个问题。
回顾这一问题的核心是StarDataProvider, 它是一个非常简单的类别, 负责从 SQLite 数据库获取我们恒星的数据, 拥有一个带有背景 QS 的专用调度队列, 并注意这是为了确保数据获取不会与 UI 竞争 。
有两个API被曝光。
一个用于不同步地装入数据 使用这个大中央大精灵的合成原始 和另一个同步的API, 以同步的方式装载数据。
现在,看看在真的FinishLaunchingOptions内部的实际呼叫站点, 我们正在利用非同步的API, 但也在利用发送信号的示意图, 以确保我们等待所有数据被获取, 然后再开始绘制我们桌面视图的实际第一框架。
现在,如果我们要这样做, 我们应该使用正确的货币原始, 这是同步原始 在GCD。
现在使用正确的货币原始,大中大灾难将暂时将主线的优先级传播到工人线上,并将它提升到不活动用户,使其匹配。
所以,现在,我认为我们有潜力 解决优先倒置问题, 但我在这里注意到还有一个问题。
加载StarDataSync API 将接受一系列行来装入数据 。
就我们的情况而言,我们正在从0排到最后一排装货, 基本上就是所有东西。
现在,当你考虑一下,第一个框架 只能适应数量有限的细胞, 这些细胞可能处于屏幕的大小。
就星探者来说,大概10到15岁左右,视装置而定。
所以,让我们继续优化它, 而不是装载所有东西, 让我们只装载前20行, 仅仅足够以同步的方式画出表视图的第一个框架。
之后,我们应该把剩下的全部 都沉闷在背景中 并且只在发射完成后更新表格视图
让我们继续前进。
最后,但并非最不重要的是,回到追踪的轨道上。
最后一个阶段是我们的第一个框架。
请注意这个阶段花了951毫秒, 时间很长, 因为这只负责布局工作, 完成第一个框架。
现在让我们更深入地下潜, 它指向了我们 星表主计长, 和看详细的堆放痕迹, 我们看到了许多工作 和一个CellforRowAt回调, 负责做 单元格的布局工作。
让我们继续 并扩展它。
当我们扩大书架追踪时, 它指向了我们 星际细节控制器的很多初始化工作, 它在CPU上花费了882毫秒。
所以,在这一点上,我们已经确定 这几乎就是这里的瓶颈。
让我们来看看我们的代码。
现在看下CellforRowAt回调中的表视图控制器, 我们使用自定义单元格创建单元格, 同时,我们投入了一种投机优化, 也就是在暖热前缓存详细 Vew 的详细查看控制器, 就像我们做布局工作一样 。
这是希望简化从表格到详细观点的过渡过程。
但正如我们在追踪中看到的那样,这不会造成高昂的成本。
现在退后一点, 当你仔细想想, 详细的观点对于我们的第一个框架来说 实在是说不通。
只有当用户在手机上监听时才有意义。
所以,让我们继续 并推迟这项工作。
或许是SelectRowAt回调,用户在窃听手机时会引用。
因此,在这一点上,我们已经对星体搜索者做了一些改进, 或优化。
所以,让我们继续 并重新描述它。
现在,这里要指出的一件事是,当你作出渐进式的改变时,你应该随着进展不断地重新衡量和调整。
这样,你就能真正理解 你渐进式变化的准确影响。
但是为了他的演示,我们实际上已经 把所有的变化都汇总到一个中, 为了时间和繁荣。
有个小UI故障 但我们可以马上看到 我们的发射在500毫秒以下
现在,正如我早些时候所说的那样,特征分析机制本身的确要付出代价。
因此,为了更好地了解我们的用户会经历什么, 让我们继续利用新的XCTest API 来测量我们的测试中的发射性能。
只要几行代码 我们就能将发射性能测试 或任何性能测试 与XCTest结合起来
让我们继续 并踢了这一点。
现在,XCTest将做一次失败的发射尝试, 从而消除冷发射带来的差异。
随后,它将进行规定的迭代次数或默认的五次发射迭代,并测量所花费的时间。
之后,它将对这些数据进行精确的统计。
完成测试需要几分钟时间 现在我们从2号开始发射星探
5秒到刚超过300毫秒
为了结束演示,我想给你们展示一下UI上这个样子。
所以,让我们确保 我们杀了星探者。
这么快就来了
谢谢
回到你身边,斯宾塞
谢谢 丹 感谢您在Xcode 工具 AppLaunchTemplate上 展示了如何使用Xcode 工具 AppLaunchTemplate 来改进我们的应用程序启动经验的精彩演示
所以,我们意识到,在你们的代码基础中, 你不可能在代码中找到几个地方, 你可以用几条线来修复, 并且得到如此重大的改进。
更有可能的是,你将不得不 找到一堆5到10毫秒的赢家, 然后堆叠所有这些在一起。
我们想让你知道,我们得到了你的支持。
我们一直在做一吨的 iOS优化 来改进你的应用程序的启动 帮助你达到你的目标
我要特别请各位发言。
如前所述,Dyld3在你演示中看到的应用程序中, 将你的运行时间依赖性带入了缓存, 这提供了巨大的改进。
还优化了调度仪表,以帮助确定发射期间工作的优先次序。
我们还将自动布局和目标C置于显微镜之下,并在那里做了一些优化。
最后,我们有令人兴奋的改变 应用软件包装今年晚些时候到来。
我们认为,这些变化应导致大大改进应用软件,但很少或根本没有通过。
所以,让我们用一些诀窍和技巧来总结一下 如何确保你的应用程序 保持令人愉快,一旦你完成了这一切工作。
首先,不要让表演是事后的思考。
您应该开始研究它, 并在每一个错误修正的开始, 在每个重构因素的开始, 以及每个特性的开始, 开始考虑它。
这是因为它非常容易引入回归, 特别是像2毫秒这样的一个小的。
问题是这些小问题加起来就是一个大问题 如果你不立即解决它们 很难找到它们全部
为了做到这一点,为了检测这些回归,你应该计划应用软件的发射时间,并定期进行测试。
这将确保你达到你的目标 并且立即知道 你是否从目标中倒退了
您也应查看新的 Xcode 组织器, 使您知道应用程序在字段中是如何运行的 。
在iOS 13中,对于已选择的用户,将收集应用软件的功率和性能衡量标准。
然后,它们将在24小时内汇总,并发回组织者,以便您通过软件版本和装置版本以直方图的形式查看。
但是,如果你想多控制一下这些数据, 你可以采用MetricKit。
MetricKit 允许您指定自定义功率和性能衡量标准 。
现在和组织者一样,这些数据将在24小时的时间内收集并汇总,然后在应用软件中通过代表方法将数据交还给你。
从那里,你可以自由处理你认为合适的数据。
为了了解更多这方面的情况,我们建议你检查一下2019年WWW的改进电池寿命和性能。
总而言之,我们希望你今天 开始理解你的应用程序的启动 与新的ApplauchTemplate 在Xcode工具。
看看能不能找到机会来尽量减少、优先安排和优化你的工作。
接下来,虽然计划良好,但并非所有优化都能成功,例如丹在他的演示书中谈到的变暖前详细视频控制器。
所以,一定要测量,而不是估计, 每当你改变时的性能。
再说一遍,无意中引入回归非常容易。
最后,你应该跟踪你在所有发展阶段的表现。
这意味着利用新的XCTest应用系统对各种装置的发射测量,并可能将其与持续整合结合起来。
这将确保您 持续发送一个令人愉快的应用程序启动 给您的所有用户 他们的设备。
详情请查看我们今天提到的会谈,星期五下午休息愉快。
谢谢
[掌声]
